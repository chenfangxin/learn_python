# 类

+ 类的定义
+ 类成员与实例成员
+ 类方法，实例方法和静态方法
+ 类的继承
+ 运算符重载

--------------------------------------------------------------------------------
## 类的定义

Python中，定义类的语法如下：
```
class CLASS_NAME(Bases) :
	def __init__(self, args) :
		<statements>
```
**注意：**在Python中，`class语句`是可执行的，用于产生**类对象**。

Python中类的成员函数的第一个参数为`self`，表示调用该函数的实例； Python中，类成员函数的命名规则如下：
+ 以`__`开始并且以`__`结尾的成员，用于特殊功能(Magic Methods)
+ 只以`__`开始的成员，是私有成员

> 其实Python中，类的所有成员都是共有的，所谓**私有**其实是语法糖 —— Python会将这些成员改成别的名字，以防止外部的直接访问。

--------------------------------------------------------------------------------
## 类成员与实例成员

类名和实例名都可视为**名字空间**。内置函数`dir()`能返回类或实例的所有可用属性。

根据Python中的[属性查找规则](descriptor.md#属性查找规则)，通过类名或实例名，都可以访问类成员；但**只能**通过实例名访问实例成员，如下示例：
```
class A:
	x = 1 # x是类成员
	def __init__(self):
		self.y = 1	# 添加实例成员y
	def add(self, i):
		self.y += i

a = A()
dir(A) # A的类成员中包含x, add
dir(a) # a的实例成员中包含x, y, add
A.x # 通过类名访问类成员
a.x # 通过实例名访问类成员
a.x = 3 # 给实例成员赋值，不影响类成员A.x
a.y # 通过实例名访问实例成员
a.add(1)	# 通过实例名调用成员函数
A.add(a, 1) # 通过类名调用成员函数
```

> 通过类名调用成员函数，有一个常见的用途，就是子类的成员函数中，显式调用父类的成员函数。

--------------------------------------------------------------------------------
## 类方法，实例方法和静态方法

根据类的成员函数，能访问的数据的不同，将其分为三类：
+ 实例方法：只能通过实例名调用。定义时第一个参数为`self`(表示实例)，通过`self`访问类数据和实例数据
+ 类方法：通过类名或实例名调用。定义时使用`@classmethod`装饰器，第一个参数为`cls`(表示类)，通过`cls`访问类数据
+ 静态方法：通过类名或实例名调用。定义时使用`@staticmethod`装饰器，不需要类或实例作为参数，也不访问类数据或实例数据，相当于一个全局函数

示例如下：
```
class A:
	x = 1
	def __init__(self):
		self.y = 2	

	def foo(self):
		print "foo (%s, %s, %s)" % (self, self.x, self.y)

	@classmethod
	def class_foo(cls):
		print "clas_foo (%s, %s)" % (cls, cls.x)

	@staticmethod
	def static_foo():
		print "static_foo"

a = A()
a.foo()
a.class_foo()
a.static_foo()

A.class_foo()
A.static_foo()

```

关于装饰器的使用，详见[装饰器](decorator.md)。

--------------------------------------------------------------------------------
## 类的继承

Python中类的继承语法很简单，如下：
```
class A:
	pass

class B(A):
	pass
```

Python中还支持多重继承,如下:
```
class A:
	pass

class B:
	pass

class c(A,B):
	pass
```

在继承场景下，最重要的两个问题问题是：

+ `MRO问题`，即方法解析顺序(Method Resolution Order)，详见[MRO问题](mro.md)
+ 属性管理，即属性的查找顺序，详见[属性查找顺序](descriptor.md#属性查找顺序)

--------------------------------------------------------------------------------
## 运算符重载

Python中通过重新定义运算符对应的函数，来实现运算符重载，这些函数命名形式为``__XXX__``，这些函数称为**魔法函数(Magic Methods)**。

常用的运算符对应的函数如下：

|函数名			|运算符		|
|---------------|-----------|
|`__init__`		|构造函数	|
|`__new__`		|	|
|`__del__`		|析构函数	|
|               |   |
|`__add__`		|加(`+`)	|
|`__sub__`		|减(`-`)	|
|`__mul__`		|乘(`*`)	|
|`__div__`	    |除(`/`)	|
|`__floordiv__`	|取整(`//`)	|
|`__mod__`	    |模(`%`)	|
|`__pow__`	    |乘方(`**`)	|
|`__lshift__`	|左移(`<<`)		|
|`__rshift__`	|右移(`>>`)		|
|`__and__`	|位与(&)		|
|`__or__`	|位或(|)		|
|`__xor__`	|异或(^)		|
|           |   |
|`__iadd__` |`+=`   |
|`__isub__` |`-=`   |
|`__imul__` |`*=`   |
|`__idiv__` |`/=`   |
|`__ifloordiv__` |`//=`   |
|`__imod__` |`%=`   |
|`__ipow__` |`**=`   |
|`__ilshift__` |`<<=`   |
|`__irshift__` |`>>=`   |
|`__iand__` |`&=`   |
|`__ixor__` |`^=`   |
|`__ior__` |`|=`   |
|           |   |
|`__cmp__`	|cmp()			|
|`__lt__`	|小于(<)	|
|`__le__`	|小于等于(<=)	|
|`__gt__`	|大于(>)	|
|`__ge__`	|大于等于(>=)	|
|`__eq__`	|等于(==)	|
|`__ne__`	|不等于(!=)	|
|           |   |
|`__contains__`	|in操作	|
|`__len__`	|len()		|
|`__getitem__`	|self[key]	|
|`__setitem__`	|self[key]=value|
|`__delitem__`	|del(self[key])|
|`__missing__`	|字典key不存在时|
