# 类

+ 类的定义
+ 类成员与实例成员
+ 类方法，实例方法和静态方法
+ 类的继承
+ 运算符重载

--------------------------------------------------------------------------------
## 类的定义

Python中，定义类的语法如下：
```
class CLASS_NAME(Bases) :
	def __init__(self, args) :
		<statements>
```
**注意：**在Python中，`class语句`是可执行的，用于产生**类对象**。

Python中类的成员函数的第一个参数为`self`，表示调用该函数的实例； Python中，类成员函数的命名规则如下：
+ 以`__`开始并且以`__`结尾的成员，用于特殊功能
+ 只以`__`开始的成员，是私有成员

> 其实Python中，类的所有成员都是共有的，所谓**私有**其实是语法糖 —— Python会将这些成员改成别的名字，以防止外部的直接访问。

常见特殊功能成员：
| 名称        | 功能        |
|-------------|-------------|
|__init__()   |构造函数		|
|__del__()    |析构函数     |
|__class__	  |实例的类对象 |
|__dict__	  |本地属性	 	|

--------------------------------------------------------------------------------
## 类成员与实例成员

类名和实例名都可视为**名字空间**。内置函数`dir()`能返回类或实例的所有可用属性。 

根据Python中的属性查找规则，通过类名或实例名，访问类成员；但**只能**通过实例名访问实例成员。
关于属性的查找顺序，详见[描述符](descriptor.md)。
如下示例：
```
class A:
	x = 1 # x是类成员
	def __init__(self):
		self.y = 1	# 添加实例成员y
	def add(self, i):
		self.y += i 

a = A()
dir(A) # A的类成员中包含x, add
dir(a) # a的实例成员中包含x, y, add
A.x # 通过类名访问类成员
a.x # 通过实例名访问类成员
a.x = 3 # 给实例成员赋值，不影响类成员A.x
a.y # 通过实例名访问实例成员
a.add(1)	# 通过实例名调用成员函数
A.add(a, 1) # 通过类名调用成员函数
```

> 通过类名调用成员函数，有一个常见的用途，就是子类的成员函数中，显式调用父类的成员函数。

--------------------------------------------------------------------------------
## 类方法，实例方法和静态方法

根据类的成员函数，能访问的数据的不同，将其分为三类：
+ 实例方法：只能通过实例名调用。定义时第一个参数为`self`(表示实例)，通过`self`访问类数据和实例数据
+ 类方法：通过类名或实例名调用。定义时使用`@classmethod`装饰器，第一个参数为`cls`(表示类)，通过`cls`访问类数据
+ 静态方法：通过类名或实例名调用。定义时使用`@staticmethod`装饰器，不需要类或实例作为参数，也不访问类数据或实例数据，相当于一个全局函数

示例如下：
```
class A:
	x = 1
	def __init__(self):
		self.y = 2	

	def foo(self):
		print "foo (%s, %s, %s)" % (self, self.x, self.y)

	@classmethod
	def class_foo(cls):
		print "clas_foo (%s, %s)" % (cls, cls.x)

	@staticmethod
	def static_foo():
		print "static_foo"

a = A()
a.foo()
a.class_foo()
a.static_foo()

A.class_foo()
A.static_foo()

```

--------------------------------------------------------------------------------
## 类的继承

Python中类的继承语法很简单，如下：
```
class A:
	pass

class B(A):
	pass
```

Python中还支持多重继承,如下:
```
class A:
	pass

class B:
	pass

class c(A,B):
	pass
```

在继承场景下，最重要的两个问题问题是：

+ `MRO问题`，即方法解析顺序(Method Resolution Order)，详见[MRO问题](mro.md)
+ 属性管理，即属性的查找顺序，详见[属性查找顺序](descriptor.md#属性查找顺序)

--------------------------------------------------------------------------------
## 运算符重载

Python中通过重新定义运算符对应的函数，来实现运算符重载，这些函数命名形式为``__XXX__``。

常用的运算符对应的函数如下：

|函数名			|运算符		|
|---------------|-----------|
|`__init__`		|构造函数	|
|`__del__`		|析构函数	|
|`__add__`		|加(`+`)	|
|`__sub__`		|减(`-`)	|
|`__mul__`		|乘(`*`)	|
|`__div__`	    |除(`/`)	|
|`__mod__`	    |模(`%`)	|
|`__floordiv__`	|取整(`//`)	|
|`__rshift__`	|右移(`>>`)		|
|`__lshift__`	|左移(`<<`)		|
|`__and__`	|位与(&)		|
|`__or__`	|位或(|)		|
|`__cmp__`	|cmp()			|
|`__len__`	|len()		|
|`__lt__`	|小于/小于等于(<, <=)	|
|`__gt__`	|大于/大于等于(>, >=)	|
|`__eq__`	|等于/不等于(==, !=)	|
