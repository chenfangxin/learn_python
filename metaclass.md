# 元类

+ Python提供的各种自定义机制
+ 元类的定义
+ type 和 object

--------------------------------------------------------------------------------
Python中允许在各种场景中插入自定义逻辑：

+ 运算符计算时： 运算符重载

+ 属性访问时：

|分类		  |方法 |
|-------------|-------------------------------------------------|
|属性拦截     |`__getattr__`，`__setattr__`，`__getattribute__` |
|类属性       |`property`										|
|类属性描述符 |`__get__`，`__set__`，`__delete__`				|

+ 函数调用时：函数装饰器

+ 类实例创建时：类装饰器

+ 类对象创建时：元类

--------------------------------------------------------------------------------
## 元类的定义
在Python中，**类**也是对象，通过``class``语句创建类对象，可以对类对象做如下操作：

+ 把类赋值给一个变量
+ 作为函数参数和返回值
+ 拷贝类
+ 增加属性

在[类装饰器](decorator.md)中，已经见过了这些操作。


### 使用`type`函数

在Python中，可以通过`type()`函数，动态的创建类，`type()`的原型如下：

> type(类名，父类元组(针对继承的情况，可以为空), 包含属性的字典)

示例如下：

```
Foo = type('Foo', (), {'bar':Ture})


等同于：

class Foo(object):
	bar = Ture

```

**元类**是用来创造类的，可以称之为`类工厂`。`type`函数就是Python内建的元类。


### 使用`__metaclass__`属性

在用`class`定义类时，可以为其添加`__metaclass__`属性，例如：

```
class Foo(object):
	__metaclass__ = statements
```
如果类定义了`__metaclass__`属性，那么Python会用该属性来创建类对象。实际上，Python在创建类对象时，都会在其**继承树**中或**所在模块**中搜索`__metaclass__`属性，若找不到，才按Python内建的`type`来创建类对象。

当模块中定义了`__metaclass__`属性，意味着模块中所有的类都是通过这个元类来创建的。

`__metaclass__`中放置的是`type`或`type`的子类。

--------------------------------------------------------------------------------
## type和object

在Python中，存在两种关系：类型的继承关系，类型-实例关系。

+ 类型的继承关系：使用`__base__/__bases__`属性查看
+ 类型-实例关系：使用`__class__`属性查看

> 新式类中，`__base__`属性表示直接父类，`__bases__`属性表示继承树中基类列表

在Python中，`object`处于**继承关系**的顶端，即`object`是所有类型的父类；`type`在**类型-实例关系**的顶端，即所有类型都是`type`的实例。

`type`和`object`的关系如下：

+ `object`是`type`的一个实例，isinstance(object, type) --> true
+ `object`没有父类，`object`的定义为`class object:`
+ `type`是`object`的子类，`type`的定义为`class type(object):`
+ `type`是自己的实例，isinstance(type, type) --> true

> 可以用`isinstance()`函数，来判断一个对象是否为某个类的实例
> 可以用`issubclass()`函数，来判断是否为子类
