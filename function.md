# 函数

+ 定义函数
+ 参数和返回值
+ 变量的作用域(Scope)
+ lambda
+ 闭包

--------------------------------------------------------------------------------
## 定义函数

函数是可以重复利用的代码块，Python中定义函数的语法如下：
```
def FUNC_NAME(ARGS) :
	<statements>
```
**注意：**在Python中，定义函数的`def语句`是可执行语句，用于产生**函数对象**。
由于这一点，在函数体中执行**def语句**也是允许的（也就是可以在函数体中定义函数，函数的嵌套定义）。

--------------------------------------------------------------------------------
## 参数和返回值

在Python中，从赋值的角度理解参数和返回值的传递：
+ 参数传递：参数传递是一个赋值的过程，就是将**形参**绑定到**实参**的值上
+ 返回值：返回值的传递也是一个赋值的过程

示例如下：
```
def test(arg) :
	arg[0] = 'cfx'  # 改变形参的内容
	return arg  

a = [0,1,2,3]
b = test(a)	# 参数传递是将形参arg与实参a绑定到同一个值, 因此改变arg的内容，也反映在a上
a 
a is b  # a和b绑定到同一个值

```

**注意：**由于在Python中，函数是**第一类值**，也就是说函数可以被赋值给一个变量，
也可以作为函数的参数和返回值。

### 可变参数

```
def foo(*args, **kwargs):
	print args
	print kwargs

foo(1, 2, 3, x=4, y=5, z=6)
```

#### 参数的默认值
在Python中，可以指定函数参数的默认值，例如：
```
def foo(bar=[]):
	bar.append('baz')
	return bar
```

上例是有问题的，因为**函数参数的默认值，只在该函数定义的时候被赋值一次**，之后每次调用该函数时，如果不带参数，就会使用该初始值。
对于这种默认值可变(mutable)的情况，应该用如下方式：
```
def foo(bar=None):
	if bar is None:
		bar = []
	bar.append('baz')
	return bar
```


--------------------------------------------------------------------------------
## 变量的作用域
作用域(Scope)用来规范变量的可见性。在Python中，只有**模块(module)**，**类(class)**和**函数(def)**被视为单独的作用域，
其他代码块，比如分支(if/else)或循环(while/for)，不会引入新的作用域。

在Python中，根据`LEGB原则`来决定作用域中变量的可见性：
+ L(Local)：本地作用域，指函数体内部 
+ E(Enclosing)：嵌套作用域，指上一层函数的内部
+ G(Global)：全局作用域，指脚本文件（模块）的内部
+ B(Builtin)：内建作用域，指Python解释器内部

对变量的操作分为读/写两类，可见性是不一样的：
+ 对于读操作(引用)，会自动根据`L-->E-->G-->B`的顺序，查找变量
+ 对于写操作(赋值)，总是创建或改变本地作用域(L)中的变量。若要给上层作用域中的变量赋值，需要先将上层作用域中的变量引入本地作用域中。

通过关键字`global`，将全局作用域(G)中的变量引入本地作用域(L)中；通过关键字`nonlocal`将嵌套作用域(E)中的变量引入本地作用域(L)中。
`nonlocal`是Python 3.x引入的。

示例如下：
```
def test() :
	# global a
	a = 'cfx' # 若没有之前的global语句，a就是一个本地作用域的变量

a = [0,1,2,3]
test()
print(a)
```

--------------------------------------------------------------------------------
## lambda表达式

Python中，使用`lambda`关键字来创建匿名函数，该函数只包含一个表达式。`lambda`常被用来创建临时的，简单的小函数，省去冗长的函数命名/定义过程。

`lambda`表达式格式如下：
```
lambda [arg1,[arg2,...]] : expression
```

--------------------------------------------------------------------------------
## 闭包(Closure)

闭包(Closure)是词法闭包(Lexial Closure)的简称。简单来说闭包就是自带运行状态的**函数**。

闭包的示例如下：
```
def newcounter():
	i = 0
	def func():
		nonlocal i
		i = i + 1
		return i
	return func

a = newcounter()
print(a())
print(a()) #每次调用结果都不同，说明函数a能记住自己的状态(即i)

b = newcounter()
print(b())
print(b())
```

由上面的示例，可知形成闭包的条件：
+ 函数是第一类值
+ 允许函数的嵌套定义
+ 函数能使用外部变量

闭包的概念对于理解[装饰器](decorator.md)非常重要。
