# 类

+ 类的定义
+ 类成员与实例成员
+ 类方法，实例方法和静态方法
+ 类的继承
+ 运算符重载

--------------------------------------------------------------------------------
## 类的定义

Python中，定义类的语法如下：
```
class CLASS_NAME(Bases) :
	def __init__(self, args) :
		<statements>
```
**注意：**在Python中，`class语句`是可执行的，用于产生**类对象**。

Python中类的成员函数的第一个参数为`self`，表示调用该函数的实例； Python中，类成员函数的命名规则如下：
+ 以`__`开始并且以`__`结尾的函数，是特殊功能函数(例如以`__init__`函数作为构造函数；以`__del__`函数作为析构函数)
+ 只以`__`开始的成员，是私有成员

> 其实Python中，类的所有成员都是共有的，所谓**私有**其实是语法糖 —— Python会将这些成员改成别的名字，以防止外部的直接访问。


--------------------------------------------------------------------------------
## 类成员与实例成员

类名和实例名都可视为**名字空间**。可以这么认为：Python在生成实例时，实例先`继承`类的名字空间中的所有成员，然后再添加新的成员或给原来成员赋值(绑定到新的值)。 可以通过类名或实例名，访问类成员；但**只能**通过实例名访问实例成员。
如下示例：
```
class A:
	x = 1 # x是类成员
	def __init__(self):
		self.y = 1	# 添加实例成员y
	def add(self, i):
		self.y += i 

a = A()
dir(A) # A的类成员中包含x, add
dir(a) # a的实例成员中包含x, y, add
A.x # 通过类名访问类成员
a.x # 通过实例名访问类成员
a.x = 3 # 给实例成员赋值，不影响类成员A.x
a.y # 通过实例名访问实例成员
a.add(1)	# 通过实例名调用成员函数
A.add(a, 1) # 通过类名调用成员函数
```
> 通过类名调用成员函数，有一个常见的用途，就是子类的成员函数中，显式调用父类的成员函数。

--------------------------------------------------------------------------------
## 类方法，实例方法和静态方法

根据类的成员函数，能访问的数据的不同，将其分为三类：
+ 实例方法：只能通过实例名调用。定义时第一个参数为`self`(表示实例)，通过`self`访问类数据和实例数据
+ 类方法：通过类名或实例名调用。定义时使用`@classmethod`装饰器，第一个参数为`cls`(表示类)，通过`cls`访问类数据
+ 静态方法：通过类名或实例名调用。定义时使用`@staticmethod`装饰器，不需要类或实例作为参数，也不访问类数据或实例数据，相当于一个全局函数

示例如下：
```
class A:
	x = 1
	def __init__(self):
		self.y = 2	

	def foo(self):
		print "foo (%s, %s, %s)" % (self, self.x, self.y)

	@classmethod
	def class_foo(cls):
		print "clas_foo (%s, %s)" % (cls, cls.x)

	@staticmethod
	def static_foo():
		print "static_foo"

a = A()
a.foo()
a.class_foo()
a.static_foo()

A.class_foo()
A.static_foo()

```

--------------------------------------------------------------------------------
## 类的继承

从**名字空间**的角度来理解，继承就是把父类名字空间中的成员放到子类名字空间中，父类成员在子类名字空间中的**可见性**如下：
+ 子类拥有所有父类的成员，若子类没有给其赋新值，则子类成员与父类成员绑定到相同的值
+ 在多重继承中，按继承声明的顺序，使用第一个出现的父类成员
+ 在多层继承中，按**深度优先**的原则，使用第一个出现的父类成员

根据上面的规则，针对子类的构造函数，有如下规则：
+ 如果子类没有定义构造函数，则自动调用父类的构造函数；若子类重新定义了构造函数，则需要显式调用父类的构造函数
+ 在多重继承中，若子类没有定义构造函数，则按继承声明的顺序，自动调用**第一个父类**的构造函数
+ 在多层继承中，若子类没有定义构造函数，则按**深度优先**的原则，自动调用**第一个父类**的构造函数

示例如下：
```
class A:
	x = 1
	def __init__(self):
		print "In A.__init__"
class B(A):
	x = 2
	def __init__(self):
		print "In B.__init__"
class C(A):
	x = 3
	def __init__(self):
		print "In C.__init__"

class D(B,C):
	pass

d = D() # 自动调用B的构造函数
```
--------------------------------------------------------------------------------
## 运算符重载

Python中通过重新定义运算符对应的函数，来实现运算符重载，这些函数命名形式为``__XXX__``。

常用的运算符对应的函数如下：

|函数名			|运算符		|
|---------------|-----------|
|`__init__`		|构造函数	|
|`__del__`		|析构函数	|
|`__add__`		|加(`+`)	|
|`__sub__`		|减(`-`)	|
|`__mul__`		|乘(`*`)	|
|`__div__`	    |除(`/`)	|
|`__mod__`	    |模(`%`)	|
|`__floordiv__`	|取整(`//`)	|
|`__and__`	|位与(&)		|
|`__or__`	|位或(|)		|
|`__cmp__`	|cmp()			|
|`__len__`	|len()		|
|`__lt__`	|小于/小于等于(<, <=)	|
|`__gt__`	|大于/大于等于(>, >=)	|
|`__eq__`	|等于/不等于(==, !=)	|
